lst = c(1,1)
lst
par(mfrow=lst)
hist(x)
hist(x, col="green")
hist(y)
plot(x,y)
plot(x,y, pch = "20")
plot(x,y, pch = 20)
plot(x,y, pch = 20, bg = "grey")
plot(x,y, pch = 20, bg = "green")
plot(x,y, pch = 20, bg = "green")
args(par)
par
par("mfrow")
plot(x,y, pch = 20, title="This is a test")
plot(x,y, pch = 20)
plot(x,y)
title("This is my title")
par(pch = 3)
plot(x, y)
plot(x, y, ylab="This is y")
plot(x, y, ylab="This is y", xlab="This is x")
title("This is my title")
g <- lm(x, y)
g <- lm(x, y, x ~ y)
g <- lm(x, y, x)
g <- lm(x)
library(datasets)
data(airquality)
colnames(airquality)
plot(airquality$Ozone, airquality$Wind)
g <- lm(airquality$Ozone, airquality$Wind, airquality)
library(lattice)
library(datasets)
xyplot(Ozone ~ Wind, data = airquality)
airquality <- transfrom(airquality, Month = factor(Month))
airquality <- transform(airquality, Month = factor(Month))
xyplot(Ozone ~ Wind | Month, data = airquality, layout = c(5,1))
p <- xyplot(Ozone ~ Wind, data = airquality)
print (p)
str(p)
type(p)
typeof(p)
ll
p
p
print(x)
print(p)
install.packages("yaml")
install.packages("htmltools")
install.packages("caTools")
install.packages("bitops")
install.packages("rmarkdown")
install.packages("knitr")
install.packages("markdown")
install.packages("slidify")
install.packages("slidify")
install.pkackages("knitr")
install.packages("knitr")
install.packages("slidfy")
install.packages("slidify")
knitr2html("PA1_template.Rmd")
library(knitr)
knitr2html("PA1_template.Rmd")
dataset(mtcars)
load(mtcars)
package(mtcars)
data(mtcars)
mydata <- na.omit(mtcars)
mydata <- scale(mydata)
wss <- (nrow(mydata) - 1) * sum(apply(mydata, 2, var))
str(mydata)
names(mtcars)
mpg
attach(mtcars)
mpg
table(cyl)
barplot(cyl)
barplot(table(cyl))
stem(mpg)
hist(mpg)
boxplot(mpg)
sd(mpg)
mpg[cyl == 4]
plot(cyl, mpg)
plot (mpg, cyl)
simple.lm(cyl,mpg)
simple.lm(cyl, mpg)
lm
lm(cyl, mpg)
tapply(mpg, cyl, mean)
plot(hp, mpg, pch=cyl)
legend(250, 30, pcg=c(4,5,8))
data(chickwts)
attach(chickwts)
names(chickwts)
boxplot(weight ~ feed)
our.mu <- mean(weight)
out.mu
our.mu
just.casein = weight[feed == 'casein']
t.test(just.casein, mu = our.mu)
t.test(weight[feed == 'casein'], weight[feed == 'sunflower'])
t.test(weight[feed == 'casein'], weight[feed == 'sunflower'], var.equal=TRUE)
qinf(p=0.75, min=0, max=1)
qunif(p=0.75, min=0, max=1)
x <- 1:4
p <- x/sum(x)
temp <-rbind(x, p)
rownames(temp) <- c("X", "Prob")
temp
Xmean <- sum(temp["x",]) * temp(["Prob",])
Xmean <- sum(temp["x",] * temp["Prob",])
Xmean <- sum(temp["x",] * temp["Prob",])
x <- 1:4
p <- x/sum(x)
temp <- rbind(x, p)
rownames(temp) <- c("X", "Prob")
temp
Xmean <- sum(temp["X",] * temp["Prob",])
Xmean
Ppregnant_pos = 0.75*0.30/(0.75*0.30+0.48*0.70)
round(Ppregnant_pos*100)
install.packages("swirl")
library(swirl)
install_from_swirl("Statistical Inference")
install_from_swirl("Statistical Inference")
swirl()
install_from_swirl("Statistical Inference")
library(swirl)
install_from_swirl("Statistical Inference")
library(devtools)
install.packages("devtools")
install_from_swirl("Statistical Inference")
install_from_swirl("Statistical Inference")
power.t.test(n=100,delta=.01,sd=0.04,type="one.sample",alternative = "one.sided")
lines(xfit, yfit, pch=22, col="green")
install.packages("UsingR")
par(mfrow=c(1,2))
library(UsingR);
data(galton)
hist(galton$child, col="blue", breaks = 100)
hist(galton$parent, col="blue", breaks=100)
install.packages("shiny")
attach(mtcars)
plot(wt, mpg)
abline(lm(mppg-wt))
abline(lm(mpg-wt))
abline(lm(mpg~wt))
title("Regression of MPG on Weight")
hist(mtcars$mpg)
hist(mtcars$mpg, breaks=12, col="red")
x <- mtcars$mpg
h <- hist(x, breaks=10, col="red", xlab="Miles Per Gallon", main="Historgram with Normal Curve")
yfit <- seq(min(x), max(x), length=40)
yfit <- yfit*diff(h$mids[1:2])*lenght(x)
yfit <- yfit*diff(h$mids[1:2])*length(x)
myts <- ts(myvector, start=c(2009, 1), end=c(2014, 12), frequency=12)
myts <- ts(myvector, start=c(2009, 1), end=c(2014, 12), frequency=12)
myts <- ts(v, start=c(2009, 1), end=c(2014, 12), frequency=12)
v <- c()
myts <- ts(v, start=c(2009, 1), end=c(2014, 12), frequency=12)
help(ts)
jj
install.packages("astsa")
library(astsa)
jj
plot(jj, ylab="Earnings per Share", main="J & J")
#----------------------------------------------
#
# Data Science 350
# Aleksey Kramer
# Homework - Week 3
#
#----------------------------------------------
# Create doors.  0 means goat, 1 means prise
doors <- c(0,0,0)
# Set the number of simulations (n)
n = 100000
# Simulation for no switching
before_no_switches <- Sys.time()
no_switches = sapply(1:n, function(x){
# Set location of the prise behind one of the doors (randomly)
prise <- sample(1:3, 1)
doors[prise] <- 1
# Select a random answer to stay with (no switching doors)
attempt <- sample(1:3, 1)
stay <- doors[attempt] == 1
# Reset the doors to initial conditions
doors[prise] <- 0
# Return TRUE/FALSE converted to numbers
return(stay + 0)
})
after_no_switches <- Sys.time()
probability_of_wins_if_not_switched <- length(no_switches[no_switches == 1]) / n
variance_if_not_switched <- var(no_switches)
time_to_run_not_switched <- after_no_switches - before_no_switches
# Simulation for switching
before_switches <- Sys.time()
switches = sapply(1:n, function(x){
# Set location of the prise behind one of the doors (randomly)
prise <- sample(1:3, 1)
doors[prise] <- 1
# Select a random answer to switch from later
initial_attempt <- sample(1:3, 1)
# Host opens a door with no prise
host_door <- sample(1:3, 1)
if(initial_attempt == host_door) {
repeat {
host_door <- sample(1:3, 1)
if(initial_attempt != host_door) {
if(doors[host_door] == 0)
break
}
}
} else if(doors[host_door] != 0) {
repeat {
host_door <- sample(1:3, 1)
if(initial_attempt != host_door) {
if(doors[host_door] == 0)
break
}
}
}
# Find the switch door
repeat {
switch_guess <- sample(1:3, 1)
if(switch_guess != initial_attempt) {
if(switch_guess != host_door) {
break
}
}
}
# Test if the guess is correct and the prise is won
result <- doors[switch_guess] == 1
# Reset the doors to initial conditions
doors[prise] <- 0
# Return TRUE/FALSE converted to numbers
return(result + 0)
})
after_switches <- Sys.time()
probability_of_wins_if_switched <- length(switches[switches == 1]) / n
variance_if_switched <- var(switches)
time_to_run_switches <- after_switches - before_switches
print(paste("Probability of winning if not switched is:", probability_of_wins_if_not_switched))
print(paste("Variance of winning if not switched is:", variance_if_not_switched))
print(paste("Time to run not switched:", time_to_run_not_switched))
print(paste("Probability of winning if switched is:", probability_of_wins_if_switched))
print(paste("Variance of winning if switched is:", variance_if_switched))
print(paste("Time to run switches:", time_to_run_switches))
#----------------------------------------------
#
# Data Science 350
# Aleksey Kramer
# Homework - Week 3
#
#----------------------------------------------
# Create doors.  0 means goat, 1 means prise
doors <- c(0,0,0)
# Set the number of simulations (n)
n = 100000
# Simulation for no switching
before_no_switches <- Sys.time()
no_switches = sapply(1:n, function(x){
# Set location of the prise behind one of the doors (randomly)
prise <- sample(1:3, 1)
doors[prise] <- 1
# Select a random answer to stay with (no switching doors)
attempt <- sample(1:3, 1)
stay <- doors[attempt] == 1
# Reset the doors to initial conditions
doors[prise] <- 0
# Return TRUE/FALSE converted to numbers
return(stay + 0)
})
after_no_switches <- Sys.time()
# Accumulating results from running no_switches simulation
probability_of_wins_if_not_switched <- length(no_switches[no_switches == 1]) / n
variance_if_not_switched <- var(no_switches)
time_to_run_not_switched <- after_no_switches - before_no_switches
# Simulation for switching
before_switches <- Sys.time()
switches = sapply(1:n, function(x){
# Set location of the prise behind one of the doors (randomly)
prise <- sample(1:3, 1)
doors[prise] <- 1
# Select a random answer to switch from later
initial_attempt <- sample(1:3, 1)
# Host opens a door with no prise
host_door <- sample(1:3, 1)
if(initial_attempt == host_door) {
repeat {
host_door <- sample(1:3, 1)
if(initial_attempt != host_door) {
if(doors[host_door] == 0)
break
}
}
} else if(doors[host_door] != 0) {
repeat {
host_door <- sample(1:3, 1)
if(initial_attempt != host_door) {
if(doors[host_door] == 0)
break
}
}
}
# Find the switch door
repeat {
switch_guess <- sample(1:3, 1)
if(switch_guess != initial_attempt) {
if(switch_guess != host_door) {
break
}
}
}
# Test if the guess is correct and the prise is won
result <- doors[switch_guess] == 1
# Reset the doors to initial conditions
doors[prise] <- 0
# Return TRUE/FALSE converted to numbers
return(result + 0)
})
after_switches <- Sys.time()
# Accumulating results for running switches simulation
probability_of_wins_if_switched <- length(switches[switches == 1]) / n
variance_if_switched <- var(switches)
time_to_run_switches <- after_switches - before_switches
# Printing out results
print(paste("Probability of winning if not switched is:", probability_of_wins_if_not_switched))
print(paste("Variance of winning if not switched is:", variance_if_not_switched))
print(paste("Time to run not switched:", time_to_run_not_switched))
print("")
print(paste("Probability of winning if switched is:", probability_of_wins_if_switched))
print(paste("Variance of winning if switched is:", variance_if_switched))
print(paste("Time to run switches:", time_to_run_switches))
install.packages("twitteR")
install.packages("twitteR")
install.packages("devtools")
setRepositories(graphics = getOption("menu.graphics"),
ind = NULL, addURLs = character())
6
setRepositories(graphics = getOption("menu.graphics"), ind = NULL, addURLs = character())
install.packages("ggplot2")
library(twitteR)
install.packages("twitteR"")
C
)
""
install.packages("twitteR")
install.packages("devtools")
devtools::install_version("httr", version="0.6.0", hrpos="http://cran.us.r-project.org")
devtools::install_version("httr", version="0.6.0", repos="http://cran.us.r-project.org")
devtools::install_version("httr", version="0.6.0", repos="http://cran.us.r-project.org")
library(httr)
library(twitteR)
library(devtools)
devtools::install_version("httr", version="0.6.0", repos="http://cran.us.r-project.org")
shapiro.test(rnorm(100, mean=5, sd=3))
shapiro.test(rnorm(100, mean=5, sd=2))
shapiro.test(rnorm(10000, mean=5, sd=3))
shapiro.test(rnorm(5000, mean=5, sd=3))
shapiro.test(runif(5000, min = 2, max = 4))
plot(rnorm(100))
plot(rnorm(100), type = "l")
plot(runif(100))
plot(runif(100), type = "l")
plot(runif(100), type = "l")
hist(rnorm(100))
hist(runif(100))
hist(rnorm(100, mean = 0, sd = 2))
hist(rnorm(1000, mean = 0, sd = 2))
hist(rnorm(5000, mean = 0, sd = 2))
instlal.packages("fitdistrplus")
install.packages('fitdistrplus')
install.packages('logspline')
x <- c(37.50,46.79,48.30,46.04,43.40,39.25,38.49,49.51,40.38,36.98,40.00,
38.49,37.74,47.92,44.53,44.91,44.91,40.00,41.51,47.92,36.98,43.40,
42.26,41.89,38.87,43.02,39.25,40.38,42.64,36.98,44.15,44.91,43.40,
49.81,38.87,40.00,52.45,53.13,47.92,52.45,44.91,29.54,27.13,35.60,
45.34,43.37,54.15,42.77,42.88,44.26,27.14,39.31,24.80,16.62,30.30,
36.39,28.60,28.53,35.84,31.10,34.55,52.65,48.81,43.42,52.49,38.00,
38.65,34.54,37.70,38.11,43.05,29.95,32.48,24.63,35.33,41.34)
x
clear
cear
x
descdist(x, discrete = FALSE)
descdist(x, discrete = FALSE)
?fitdistrplus
require(fitdistrplus)
require(logspline)
descdist(x, discrete = FALSE)
fit.weibull <- fitdist(x, "weibull")
fit.norm <- fitdist(x, "norm")
plot(fit.norm)
?fitdist
fit.norm <- fitdist(x)
fit.norm <- fitdist(x, "norm")
AIC
?AIC
lm1 <- lm(Fertility ~ . , data = swiss)
AIC(lml)
AIC(lm1)
stopifnot(all.equal(ACI(lm1), AIC(logLik(lm1))))
stopifnot(all.equal(AIC(lm1), AIC(logLik(lm1))))
BIC(lm1)
lm2 <- update(lm1, . ~ . -Examination)
AIC(lm1, lm2)
?help
help("datasets")
attach(airquality)
d <- airquality
d
str(d)
pairs(d)
plot(ozone ~ Solar.R)
plot(Ozone ~ Solar.R)
abline(Ozone ~ Solar.R)
lm.ozone <- lm(Ozone ~ Solar.R)
lm
summary(lm.ozone)
sd(Ozone)
sd(Ozone, na.rm = T)
install.packages(c("akima", "curl", "data.table", "devtools", "dplyr", "evaluate", "fitdistrplus", "git2r", "gstat", "intervals", "jsonlite", "MASS", "mime", "pls", "R6", "raster", "Rcpp", "RcppArmadillo", "rversions", "scales", "sp", "splancs", "twitteR", "xml2"))
magic04 = read.table("http://archive.ics.uci.edu/ml/machine-learning-databases/magic/magic04.data", header = F, sep=",")
View(magic04)
View(magic04)
split.data <- function(data, p = 0.7, s = 666){
set.seed(s)
index <- sample(1:dim(data)[1])
train <- data[index[1:floor(dim(data)[1] * p)], ]
test <- data[index[((ceiling(dim(data)[1] * p)) + 1):dim(data)[1]], ]
return(list(train = train, test = test))
}
dati = split.data(magic04, p = 0.7)
train = dati$train
test = dati$test
library(e1071)
install.packages("e1071")
library(e1071)
model <- svm(train[,1:10],train[,11], probability = T)
# prediction on the test set
pred <- predict(model, test[,1:(dim(test)[[2]]-1)], probability = T)
table(pred,test[,dim(test)[2]])
pred.prob <- attr(pred, "probabilities")
pred.to.roc <- pred.prob[, 1]
# performance assessment
library(ROCR)
install.packages("ROCR")
library(ROCR)
pred.rocr <- prediction(pred.to.roc, as.factor(test[,(dim(test)[[2]])]))
perf.rocr <- performance(pred.rocr, measure = "auc", x.measure = "cutoff")
cat("AUC =",deparse(as.numeric(perf.rocr@y.values)),"\n")
perf.tpr.rocr <- performance(pred.rocr, "tpr","fpr")
plot(perf.tpr.rocr, colorize=T)
summary(model)
pred
summary(pred)
table(pred,test[,dim(test)[2]])
install.packages("caret")
install.packages('caret')
setwd('C:\\Users\\db345c\\Desktop\\Practical Machine Learning\\Week2')
library(caret)
library(kernlab)
install.packages('kernlab')
library(kernlab)
library(caret)
library(kernlab)
data(spam)
inTrain <- createDataPartition(y=spam$type, p=0.75, list=FALSE)
training <- spam[inTrain,]
testing <- spam[-inTrain,]
dim(training)
modelFit
modelFit <- train(type ~., data=training, method="glm")
modelFit
modelFit$finalModel
predictions <- predict(modelFit, newdata=testing)
predictions
confusionMatrix(predictions, testing$type)
library(caret)
library(kernlab)
data(spam)
# partition data 0.75 for training, 0.25 for testing, y is the variable to split on
inTrain <- createDataPartition(y=spam$type, p=0.75, list=FALSE)
# create training and testing subsets
training <- spam[inTrain,]
testing <- spam[-inTrain,]
# Display training
dim(training)
set.seed(32323)
folds <- createFolds(y=spam$type, k=10, list=TRUE, returnTrain = TRUE)
sapply(folds, length)
folds[[1]][1:10]
folds <- createFolds(y=spam$type, k=10, list=TRUE, returnTrain = FALSE)
sapply(folds, length)
set.seed(32323)
# Resampling or Bootstrapping
folds <- createResample(y=spam$type, times=10, list=TRUE)
sapply(folds, length)
folds[[1]][1:10]
set.seed(32323)
# time slicing
tme <- 1:1000
# continious value in time with 20 sample windows (predict next 10 samples out)
folds <- createTimeSlices(y=tme, initialWindow = 20, horizon=10)
names(folds)
str(folds)
folds$train[[1]]
folds$test[[1]]
